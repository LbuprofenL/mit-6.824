package main

//
// a pagerank application "plugin" for MapReduce.
//
// go build -buildmode=plugin normal_pr.go
//

import (
	"fmt"
	"sort"
	"strconv"
	"strings"

	"6.5840/mr"
)

const pageNum = 8398 // number of pages

// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
func Map(filename string, contents string) []mr.KeyValue {

	kva := []mr.KeyValue{}

	kv := mr.KeyValue{Key: string(1), Value: contents}
	kva = append(kva, kv)

	return kva
}

// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
func Reduce(key string, values []string) string {
	type kv struct {
		Key   int
		Value float64
	}

	lines := strings.Split(values[0], "\n")
	var total_rank float64
	kva := []kv{}
	for _, line := range lines {
		nums := strings.Split(line, " ")
		// ret += fmt.Sprintf("len of num is %d\n", len(nums))
		if len(nums) != 2 {
			continue
		}
		page, err := strconv.Atoi(nums[0])
		if err != nil {
			panic(err.Error())
		}
		rank, err := strconv.ParseFloat(nums[1], 64)
		if err != nil {
			panic(err.Error())
		}
		total_rank += rank
		pr := kv{Key: page, Value: rank}
		kva = append(kva, pr)
	}

	// for _, kv := range kva {
	// 	ret += fmt.Sprintf("%d: %.10f\n", kv.k, kv.v/total_rank)
	// }
	sort.Slice(kva, func(i, j int) bool {
		return kva[i].Value > kva[j].Value
	})
	ret := ""
	ret += "sorted:\n"
	for i := 0; i < len(kva); i++ {
		ret += fmt.Sprintf("%d: %.10f\n", kva[i].Key, kva[i].Value/total_rank)
	}
	return ret
}
